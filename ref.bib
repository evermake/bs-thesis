@article{Hindley1969_PrincipalTypeScheme,
  issn      = {00029947},
  url       = {http://www.jstor.org/stable/1995158},
  author    = {R. Hindley},
  journal   = {Transactions of the American Mathematical Society},
  pages     = {29--60},
  publisher = {American Mathematical Society},
  doi       = {10.2307/1995158},
  title     = {The Principal Type-Scheme of an Object in Combinatory Logic},
  volume    = {146},
  year      = {1969}
}

@article{Milner1978_TypePolymorphism,
  title    = {A theory of type polymorphism in programming},
  journal  = {Journal of Computer and System Sciences},
  volume   = {17},
  number   = {3},
  pages    = {348-375},
  year     = {1978},
  issn     = {0022-0000},
  doi      = {https://doi.org/10.1016/0022-0000(78)90014-4},
  url      = {https://www.sciencedirect.com/science/article/pii/0022000078900144},
  author   = {Robin Milner},
  abstract = {The aim of this work is largely a practical one. A widely employed style of programming, particularly in structure-processing languages which impose no discipline of types, entails defining procedures which work well on objects of a wide variety. We present a formal type discipline for such polymorphic procedures in the context of a simple programming language, and a compile time type-checking algorithm W which enforces the discipline. A Semantic Soundness Theorem (based on a formal semantics for the language) states that well-type programs cannot “go wrong” and a Syntactic Soundness Theorem states that if W accepts a program then it is well typed. We also discuss extending these results to richer languages; a type-checking algorithm based on W is in fact already implemented and working, for the metalanguage ML in the Edinburgh LCF system.}
}

@inproceedings{DamasMilner1982_TypeSchemes,
  author    = {Damas, Luis and Milner, Robin},
  title     = {Principal type-schemes for functional programs},
  year      = {1982},
  isbn      = {0897910656},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/582153.582176},
  doi       = {10.1145/582153.582176},
  booktitle = {Proceedings of the 9th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {207–212},
  numpages  = {6},
  location  = {Albuquerque, New Mexico},
  series    = {POPL '82}
}

@article{Damas1984_TypeAssignment,
  title     = {Type assignment in programming languages},
  author    = {Damas, Luis},
  journal   = {KB thesis scanning project 2015},
  year      = {1984},
  publisher = {The University of Edinburgh}
}

@inproceedings{Clement1986_MiniML,
  author    = {Cl\'{e}ment, Dominique and Despeyroux, Thierry and Kahn, Gilles and Despeyroux, Jo\"{e}lle},
  title     = {A simple applicative language: mini-ML},
  year      = {1986},
  isbn      = {0897912004},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  doi       = {10.1145/319838.319847},
  booktitle = {Proceedings of the 1986 ACM Conference on LISP and Functional Programming},
  pages     = {13–27},
  numpages  = {15},
  location  = {Cambridge, Massachusetts, USA},
  series    = {LFP '86}
}

@techreport{Remy1992_SortedEqTheoryTypes,
  title       = {{Extension of ML type system with a sorted equation theory on types}},
  author      = {R{\'e}my, Didier},
  url         = {https://inria.hal.science/inria-00077006},
  type        = {Research Report},
  number      = {RR-1766},
  institution = {{INRIA}},
  year        = {1992}
}

@misc{Kiselyov2022_OCamplTypeChecker,
  author = {Oleg Kiselyov},
  title  = {{How OCaml type checker works — or what polymorphism and garbage collection have in common}},
  url    = {https://okmij.org/ftp/ML/generalization.html},
  year   = {2022},
  month  = {01},
  day    = {9}
}

@inproceedings{Mairson1989_MLTypabilityExponential,
  author    = {Mairson, Harry G.},
  title     = {Deciding ML typability is complete for deterministic exponential time},
  year      = {1989},
  isbn      = {0897913434},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/96709.96748},
  doi       = {10.1145/96709.96748},
  booktitle = {Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {382–401},
  numpages  = {20},
  location  = {San Francisco, California, USA},
  series    = {POPL '90}
}

@article{Simon2002_SecretsGHC,
  author  = {Peyton Jones, Simon and Marlow, Simon},
  title   = {Secrets of the Glasgow Haskell Compiler inliner},
  year    = {2002},
  month   = {7},
  url     = {https://www.microsoft.com/en-us/research/publication/secrets-of-the-glasgow-haskell-compiler-inliner/},
  pages   = {393-434},
  journal = {Journal of Functional Programming},
  volume  = {12}
}

@inproceedings{Foil,
  author    = {Maclaurin, Dougal and Radul, Alexey and Paszke, Adam},
  title     = {The Foil: Capture-Avoiding Substitution With No Sharp Edges},
  year      = {2023},
  isbn      = {9781450398312},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  doi       = {10.1145/3587216.3587224},
  abstract  = {Correctly manipulating program terms in a compiler is surprisingly difficult because of the need to avoid name capture. The rapier from Peyton&nbsp;Jones and Marlow [9] is a cutting-edge technique for fast, stateless capture-avoiding substitution for expressions represented with explicit names. It is, however, a sharp tool—its invariants are tricky and need to be maintained throughout the whole compiler that uses it. We describe the foil, an elaboration of the rapier that uses Haskell’s type system to enforce the rapier’s invariants statically, preventing a class of hard-to-find bugs, but without adding any run-time overheads.},
  booktitle = {Proceedings of the 34th Symposium on Implementation and Application of Functional Languages},
  articleno = {8},
  numpages  = {10},
  location  = {Copenhagen, Denmark},
  series    = {IFL '22}
}

@inproceedings{FreeFoil,
  author    = {Kudasov, Nikolai and Shakirova, Renata and Shalagin, Egor and Tyulebaeva, Karina},
  booktitle = {2024 4th International Conference on Code Quality (ICCQ)},
  title     = {Free Foil: Generating Efficient and Scope-Safe Abstract Syntax},
  year      = {2024},
  volume    = {},
  number    = {},
  pages     = {1-16},
  keywords  = {Codes;Prototypes;Syntactics;Benchmark testing;Generators;Encoding;Safety;abstract syntax;second-order;capture-avoiding substitution;free monads},
  doi       = {10.1109/ICCQ60895.2024.10576867}
}

@inproceedings{BNFC,
  author    = {Forsberg, Markus and Ranta, Aarne},
  title     = {{BNF converter}},
  year      = {2004},
  isbn      = {1581138504},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  doi       = {10.1145/1017472.1017475},
  abstract  = {We will demonstrate BNFC (the BNF Converter) [7, 6], a multi-lingual compiler tool. BNFC takes as its input a grammar written in LBNF (Labelled BNF) notation, and generates a compiler front-end (an abstract syntax, a lexer, and a parser). Furthermore, it generates a case skeleton usable as the starting point of back-end construction, a pretty printer, a test bench, and a LaTeX document usable as language specification. The program components can be generated in Haskell, Java, C and C++ and their standard parser and lexer tools. BNFC itself was written in Haskell.The methodology used for the generated front-end is based on Appel's books on compiler construction [3, 1, 2]. BNFC has been used as a teaching tool in compiler construction courses at Chalmers. It has also been applied to research-related programming language development, and in an industrial application producing a compiler for a telecommunications protocol description language [4].BNFC is freely available under the GPL license at its website and in the testing distribution of Debian Linux.},
  booktitle = {Proceedings of the 2004 ACM SIGPLAN Workshop on Haskell},
  pages     = {94–95},
  numpages  = {2},
  keywords  = {pretty printer, parser generator, grammar, document automation, compiler construction, abstract syntax, BNF},
  location  = {Snowbird, Utah, USA},
  series    = {Haskell '04}
}

@inproceedings{SheardPeytonJones2002_TH,
  title     = {Template meta-programming for Haskell},
  author    = {Sheard, Tim and Jones, Simon Peyton},
  booktitle = {Proceedings of the 2002 ACM SIGPLAN workshop on Haskell},
  publisher = {{ACM}},
  doi       = {10.1145/581690.581691},
  pages     = {1--16},
  year      = {2002}
}

@incollection{BackusNaurForm2003,
  title     = {Backus-naur form (bnf)},
  author    = {McCracken, Daniel D and Reilly, Edwin D},
  booktitle = {Encyclopedia of Computer Science},
  pages     = {129--131},
  year      = {2003}
}

@misc{haskell_happy,
  author       = {{Haskell Community}},
  title        = {Happy - The Parser Generator for Haskell},
  year         = {2024},
  howpublished = {\url{https://github.com/haskell/happy}}
}

@misc{haskell_alex,
  author       = {{Haskell Community}},
  title        = {Alex - A Lexical Analyser Generator for Haskell},
  year         = {2024},
  howpublished = {\url{https://github.com/haskell/alex}}
}

@inproceedings{deBruijn1972,
  title        = {{Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the Church-Rosser theorem}},
  author       = {De Bruijn, Nicolaas Govert},
  booktitle    = {Indagationes mathematicae (proceedings)},
  volume       = {75},
  number       = {5},
  pages        = {381--392},
  year         = {1972},
  organization = {Elsevier},
  doi          = {https://doi.org/10.1016/1385-7258(72)90034-0}
}

@article{BirdPaterson1999_BruijnNested,
  title   = {de Bruijn notation as a nested datatype},
  volume  = {9},
  doi     = {10.1017/S0956796899003366},
  number  = {1},
  journal = {Journal of Functional Programming},
  author  = {Bird, Richard S. and Paterson, Ross},
  year    = {1999},
  pages   = {77–91}
}

@inproceedings{Bird1998_NestedDatatypes,
  author  = {Bird, Richard and Meertens, Lambert},
  year    = {1998},
  month   = {06},
  pages   = {52-67},
  title   = {Nested Datatypes.},
  volume  = {1422},
  isbn    = {978-3-540-64591-7},
  journal = {Lecture Notes in Computer Science},
  doi     = {10.1007/BFb0054285}
}

@article{PaszkeDex_2021,
  author  = {Paszke, Adam and Johnson, Daniel D. and Duvenaud, David and Vytiniotis, Dimitrios and Radul, Alexey and Johnson, Matthew J. and Ragan-Kelley, Jonathan and Maclaurin, Dougal},
  doi     = {10.1145/3473593},
  journal = {Proceedings of the ACM on Programming Languages},
  month   = aug,
  title   = {{Getting to the Point: Index Sets and Parallelism-Preserving Autodiff for Pointful Array Programming}},
  volume  = {5},
  year    = {2021}
}

@inproceedings{Traytel2011_HMCoerciveSubtyping,
  author    = {Traytel, Dmitriy
               and Berghofer, Stefan
               and Nipkow, Tobias},
  editor    = {Yang, Hongseok},
  title     = {Extending Hindley-Milner Type Inference with Coercive Structural Subtyping},
  booktitle = {Programming Languages and Systems},
  year      = {2011},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {89--104},
  abstract  = {We investigate how to add coercive structural subtyping to a type system for simply-typed lambda calculus with Hindley-Milner polymorphism. Coercions allow to convert between different types, and their automatic insertion can greatly increase readability of terms. We present a type inference algorithm that, given a term without type information, computes a type assignment and determines at which positions in the term coercions have to be inserted to make it type-correct according to the standard Hindley-Milner system (without any subtypes). The algorithm is sound and, if the subtype relation on base types is a disjoint union of lattices, also complete. The algorithm has been implemented in the proof assistant Isabelle.},
  isbn      = {978-3-642-25318-8}
}


@article{Robinson1965,
  author     = {Robinson, J. A.},
  title      = {A Machine-Oriented Logic Based on the Resolution Principle},
  year       = {1965},
  issue_date = {Jan. 1965},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {12},
  number     = {1},
  issn       = {0004-5411},
  doi        = {10.1145/321250.321253},
  journal    = {J. ACM},
  month      = jan,
  pages      = {23–41},
  numpages   = {19}
}

@software{free-foil,
  author    = {Nikolai Kudasov and
               Egor Shalagin and
               Renata Shakirova},
  title     = {fizruk/free-foil: v0.2.0},
  month     = oct,
  year      = 2024,
  publisher = {Zenodo},
  version   = {v0.2.0},
  doi       = {10.5281/zenodo.13997857},
  url       = {https://doi.org/10.5281/zenodo.13997857}
}

@article{lee1998proofs,
  title     = {Proofs about a folklore let-polymorphic type inference algorithm},
  author    = {Lee, Oukseh and Yi, Kwangkeun},
  journal   = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume    = {20},
  number    = {4},
  pages     = {707--723},
  year      = {1998},
  publisher = {ACM New York, NY, USA}
}

@article{Heeren2002_GeneralizingHM,
  title     = {Generalizing Hindley-Milner type inference algorithms},
  author    = {Heeren, BJ and Hage, Jurriaan and Swierstra, S Doaitse and others},
  year      = {2002},
  publisher = {Utrecht University: Information and Computing Sciences}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

@book{Barendregt1985,
  author    = {Hendrik Pieter Barendregt},
  title     = {The lambda calculus - its syntax and semantics},
  series    = {Studies in logic and the foundations of mathematics},
  volume    = {103},
  publisher = {North-Holland},
  year      = {1985},
  isbn      = {978-0-444-86748-3},
  timestamp = {Fri, 28 Jun 2019 12:45:52 +0200},
  biburl    = {https://dblp.org/rec/books/daglib/0067558.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@book{TaPL,
  title     = {Types and programming languages},
  author    = {Pierce, Benjamin C},
  year      = {2002},
  publisher = {MIT press}
}

@article{Swierstra2008_a_la_carte,
  title     = {Data types \`a la carte},
  volume    = {18},
  doi       = {10.1017/S0956796808006758},
  number    = {4},
  journal   = {Journal of Functional Programming},
  publisher = {Cambridge University Press},
  author    = {Swierstra, Wouter},
  year      = {2008},
  pages     = {423–436}
}

@misc{ExpressionProblem,
  author = {Philip Wadler},
  title  = {The Expression Problem},
  url    = {https://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt},
  year   = {1998},
  month  = {11},
  day    = {12},
  note   = {Accessed: 2024-11-07}
}

@article{VytiniotisJonesSchrijversSulzmann2011,
  title   = {OutsideIn(X) Modular type inference with local assumptions},
  volume  = {21},
  doi     = {10.1017/S0956796811000098},
  number  = {4–5},
  journal = {Journal of Functional Programming},
  author  = {Vytiniotis, Dimitrios and Peyton Jones, Simon and Schrijvers, Tom and Silzmann, Martin},
  year    = {2011},
  pages   = {333–412}
}

@article{Coquand1996,
  title     = {An algorithm for type-checking dependent types},
  author    = {Coquand, Thierry},
  journal   = {Science of computer programming},
  volume    = {26},
  number    = {1-3},
  pages     = {167--177},
  year      = {1996},
  publisher = {Elsevier}
}

@software{BiTTs,
  author    = {Thiago Felicissimo},
  title     = {thiagofelicissimo/BiTTs: v3},
  month     = apr,
  year      = 2024,
  publisher = {Zenodo},
  version   = {v3},
  doi       = {10.5281/zenodo.10996395},
  url       = {https://doi.org/10.5281/zenodo.10996395}
}

@article{PierceTurner2000,
  author     = {Pierce, Benjamin C. and Turner, David N.},
  title      = {Local type inference},
  year       = {2000},
  issue_date = {Jan. 2000},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {22},
  number     = {1},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/345099.345100},
  doi        = {10.1145/345099.345100},
  abstract   = {We study two partial type inference methods for a language combining subtyping and impredicative polymorphism. Both methods are local in the sense that missing annotations are recovered using only information from adjacent nodes in the syntax tree, without long-distance constraints such as unification variables. One method infers type arguments in polymorphic applications using a local constraint solver. The other infers annotations on bound variables in function abstractions by propagating type constraints downward from enclosing application nodes. We motivate our design choices by a statistical analysis of the uses of type inference in a sizable body of existing ML code.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = jan,
  pages      = {1–44},
  numpages   = {44},
  keywords   = {polymorphism, subtyping, type inference}
}

@article{OderskySulzmannWehr1999,
  title     = {Type inference with constrained types},
  author    = {Odersky, Martin and Sulzmann, Martin and Wehr, Martin},
  journal   = {Theory and practice of object systems},
  volume    = {5},
  number    = {1},
  pages     = {35--55},
  year      = {1999},
  publisher = {Wiley Online Library}
}

@inproceedings{Jones1999_TypingHaskell,
  title     = {Typing Haskell in Haskell},
  author    = {Jones, Mark P},
  booktitle = {Haskell workshop},
  volume    = {7},
  year      = {1999}
}

@inproceedings{SerranoMiraldo2018,
  author    = {Serrano, Alejandro and Miraldo, Victor Cacciari},
  title     = {Generic programming of all kinds},
  year      = {2018},
  isbn      = {9781450358354},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3242744.3242745},
  doi       = {10.1145/3242744.3242745},
  abstract  = {Datatype-generic programming is a widely used technique to define functions that work regularly over a class of datatypes. Examples include deriving serialization of data, equality or even functoriality. The state-of-the-art of generic programming still lacks handling GADTs, multiple type variables, and some other features. This paper exploits modern GHC extensions, including <pre>TypeInType</pre>, to handle arbitrary number of type variables, constraints, and existentials. We also provide an Agda model of our construction that does not require Russel’s paradox, proving the construction is consistent.},
  booktitle = {Proceedings of the 11th ACM SIGPLAN International Symposium on Haskell},
  pages     = {41–54},
  numpages  = {14},
  keywords  = {Generic programming, Haskell},
  location  = {St. Louis, MO, USA},
  series    = {Haskell 2018}
}

@inproceedings{UllrichDeMoura2020,
  author    = {Ullrich, Sebastian
               and de Moura, Leonardo},
  editor    = {Peltier, Nicolas
               and Sofronie-Stokkermans, Viorica},
  title     = {Beyond Notations: Hygienic Macro Expansion for Theorem Proving Languages},
  booktitle = {Automated Reasoning},
  year      = {2020},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {167--182},
  abstract  = {In interactive theorem provers (ITPs), extensible syntax is not only crucial to lower the cognitive burden of manipulating complex mathematical objects, but plays a critical role in developing reusable abstractions in libraries. Most ITPs support such extensions in the form of restrictive ``syntax sugar'' substitutions and other ad hoc mechanisms, which are too rudimentary to support many desirable abstractions. As a result, libraries are littered with unnecessary redundancy. Tactic languages in these systems are plagued by a seemingly unrelated issue: accidental name capture, which often produces unexpected and counterintuitive behavior. We take ideas from the Scheme family of programming languages and solve these two problems simultaneously by proposing a novel hygienic macro system custom-built for ITPs. We further describe how our approach can be extended to cover type-directed macro expansion resulting in a single, uniform system offering multiple abstraction levels that range from supporting simplest syntax sugars to elaboration of formerly baked-in syntax. We have implemented our new macro system and integrated it into the upcoming version (v4) of the Lean theorem prover. Despite its expressivity, the macro system is simple enough that it can easily be integrated into other systems.},
  isbn      = {978-3-030-51054-1}
}

@inproceedings{EisenbergWeirich2012,
  author    = {Eisenberg, Richard A. and Weirich, Stephanie},
  title     = {Dependently typed programming with singletons},
  year      = {2012},
  isbn      = {9781450315746},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2364506.2364522},
  doi       = {10.1145/2364506.2364522},
  abstract  = {Haskell programmers have been experimenting with dependent types for at least a decade, using clever encodings that push the limits of the Haskell type system. However, the cleverness of these encodings is also their main drawback. Although the ideas are inspired by dependently typed programs, the code looks significantly different. As a result, GHC implementors have responded with extensions to Haskell's type system, such as GADTs, type families, and datatype promotion. However, there remains a significant difference between programming in Haskell and in full-spectrum dependently typed languages. Haskell enforces a phase separation between runtime values and compile-time types. Therefore, singleton types are necessary to express the dependency between values and types. These singleton types introduce overhead and redundancy for the programmer.This paper presents the singletons library, which generates the boilerplate code necessary for dependently typed programming using GHC. To compare with full-spectrum languages, we present an extended example based on an Agda interface for safe database access. The paper concludes with a detailed discussion on the current capabilities of GHC for dependently typed programming and suggestions for future extensions to better support this style of programming.},
  booktitle = {Proceedings of the 2012 Haskell Symposium},
  pages     = {117–130},
  numpages  = {14},
  keywords  = {dependently typed programming, gadts, haskell, singletons},
  location  = {Copenhagen, Denmark},
  series    = {Haskell '12}
}

@article{AltenkirchChapmanUustalu2015,
  title    = {{Monads need not be endofunctors}},
  author   = {Thosten Altenkirch and James Chapman and Tarmo Uustalu},
  url      = {https://lmcs.episciences.org/928},
  doi      = {10.2168/LMCS-11(1:3)2015},
  journal  = {{Logical Methods in Computer Science}},
  volume   = {{Volume 11, Issue 1}},
  year     = {2015},
  month    = Mar,
  keywords = {Computer Science - Programming Languages ; Computer Science - Logic in Computer Science ; Mathematics - Category Theory}
}

@inproceedings{Voigtlander2008,
  author    = {Voigtl{\"a}nder, Janis},
  editor    = {Audebaud, Philippe
               and Paulin-Mohring, Christine},
  title     = {Asymptotic Improvement of Computations over Free Monads},
  booktitle = {Mathematics of Program Construction},
  year      = {2008},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {388--403},
  abstract  = {We present a low-effort program transformation to improve the efficiency of computations over free monads in Haskell. The development is calculational and carried out in a generic setting, thus applying to a variety of datatypes. An important aspect of our approach is the utilisation of type class mechanisms to make the transformation as transparent as possible, requiring no restructuring of code at all. There is also no extra support necessary from the compiler (apart from an up-to-date type checker). Despite this simplicity of use, our technique is able to achieve true asymptotic runtime improvements. We demonstrate this by examples for which the complexity is reduced from quadratic to linear.},
  isbn      = {978-3-540-70594-9},
  doi       = {10.1007/s10817-011-9225-2}
}

@book{Brady2017,
  title     = {Type-Driven Development with Idris},
  author    = {Brady, Edwin},
  year      = {2017},
  publisher = {Simon and Schuster}
}

@inproceedings{Noonan2018,
  author    = {Noonan, Matt},
  title     = {Ghosts of departed proofs (functional pearl)},
  year      = {2018},
  isbn      = {9781450358354},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3242744.3242755},
  doi       = {10.1145/3242744.3242755},
  abstract  = {Library authors often are faced with a design choice: should a function with preconditions be implemented as a partial function, or by returning a failure condition on incorrect use? Neither option is ideal. Partial functions lead to frustrating run-time errors. Failure conditions must be checked at the use-site, placing an unfair tax on the users who have ensured that the function's preconditions were correctly met.  In this paper, we introduce an API design concept called ``ghosts of departed proofs'' based on the following observation: sophisticated preconditions can be encoded in Haskell's type system with no run-time overhead, by using proofs that inhabit phantom type parameters attached to newtype wrappers. The user expresses correctness arguments by constructing proofs to inhabit these phantom types. Critically, this technique allows the library user to decide when and how to validate that the API's preconditions are met.  The ``ghosts of departed proofs'' approach to API design can achieve many of the benefits of dependent types and refinement types, yet only requires some minor and well-understood extensions to Haskell 2010. We demonstrate the utility of this approach through a series of case studies, showing how to enforce novel invariants for lists, maps, graphs, shared memory regions, and more.},
  booktitle = {Proceedings of the 11th ACM SIGPLAN International Symposium on Haskell},
  pages     = {119–131},
  numpages  = {13},
  keywords  = {API design, formal methods, higher-rank types, software engineering},
  location  = {St. Louis, MO, USA},
  series    = {Haskell 2018}
}

@article{Chargueraud2012,
  author    = {Arthur Chargu{\'{e}}raud},
  title     = {The Locally Nameless Representation},
  journal   = {Journal of Automated Reasoning},
  volume    = {49},
  number    = {3},
  pages     = {363--408},
  year      = {2012},
  url       = {https://doi.org/10.1007/s10817-011-9225-2},
  doi       = {10.1007/S10817-011-9225-2},
  timestamp = {Wed, 02 Sep 2020 13:30:05 +0200},
  biburl    = {https://dblp.org/rec/journals/jar/Chargueraud12.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{McBride2018,
  author    = {Conor McBride},
  editor    = {Robert Atkey and
               Sam Lindley},
  title     = {Everybody's Got To Be Somewhere},
  booktitle = {Proceedings of the 7th Workshop on Mathematically Structured Functional
               Programming, MSFP@FSCD 2018, Oxford, UK, 8th July 2018},
  series    = {{EPTCS}},
  volume    = {275},
  pages     = {53--69},
  year      = {2018},
  url       = {https://doi.org/10.4204/EPTCS.275.6},
  doi       = {10.4204/EPTCS.275.6},
  timestamp = {Mon, 10 Sep 2018 16:20:34 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1807-04085.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{Hamana2017,
  author     = {Hamana, Makoto},
  title      = {How to prove your calculus is decidable: practical applications of second-order algebraic theories and computation},
  year       = {2017},
  issue_date = {September 2017},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {1},
  number     = {ICFP},
  url        = {https://doi.org/10.1145/3110266},
  doi        = {10.1145/3110266},
  abstract   = {We present a general methodology of proving the decidability of equational theory of programming language concepts in the framework of second-order algebraic theories. We propose a Haskell-based analysis tool SOL, Second-Order Laboratory, which assists the proofs of confluence and strong normalisation of computation rules derived from second-order algebraic theories.  To cover various examples in programming language theory, we combine and extend both syntactical and semantical results of second-order computation in a non-trivial manner. We demonstrate how to prove decidability of various algebraic theories in the literature. It includes the equational theories of monad and lambda-calculi, Plotkin and Power's theory of states, and Stark's theory of pi-calculus.},
  journal    = {Proc. ACM Program. Lang.},
  month      = {08},
  articleno  = {22},
  numpages   = {28},
  keywords   = {Haskell, Theory, algebra, confluence, equational logic, lambda-calculus, monad, second-order algebraic theory, semantics, termination}
}

@article{Huet1975,
  title   = {A unification algorithm for typed $\lambda$-calculus},
  journal = {Theoretical Computer Science},
  volume  = {1},
  number  = {1},
  pages   = {27-57},
  year    = {1975},
  issn    = {0304-3975},
  doi     = {https://doi.org/10.1016/0304-3975(75)90011-0},
  author  = {G.P. Huet}
}

@inproceedings{Kudasov2023,
  author    = {Kudasov, Nikolai},
  title     = {{E-Unification for Second-Order Abstract Syntax}},
  booktitle = {8th International Conference on Formal Structures for Computation and Deduction (FSCD 2023)},
  pages     = {10:1--10:22},
  series    = {Leibniz International Proceedings in Informatics (LIPIcs)},
  isbn      = {978-3-95977-277-8},
  issn      = {1868-8969},
  year      = {2023},
  volume    = {260},
  editor    = {Gaboardi, Marco and van Raamsdonk, Femke},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address   = {Dagstuhl, Germany},
  url       = {https://drops.dagstuhl.de/opus/volltexte/2023/17994},
  urn       = {urn:nbn:de:0030-drops-179944},
  doi       = {10.4230/LIPIcs.FSCD.2023.10},
  annote    = {Keywords: E-unification, higher-order unification, second-order abstract syntax}
}

@inproceedings{McBrideMcKinna2004,
  author    = {McBride, Conor and McKinna, James},
  title     = {Functional pearl: i am not a number--i am a free variable},
  year      = {2004},
  isbn      = {1581138504},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1017472.1017477},
  doi       = {10.1145/1017472.1017477},
  abstract  = {In this paper, we show how to manipulate syntax with binding using a mixed representation of names for free variables (with respect to the task in hand) and de Bruijn indices [5] for bound variables. By doing so, we retain the advantages of both representations: naming supports easy, arithmetic-free manipulation of terms; de Bruijn indices eliminate the need for α-conversion. Further, we have ensured that not only the user but also the implementation need never deal with de Bruijn indices, except within key basic operations.Moreover, we give a hierarchical representation for names which naturally reflects the structure of the operations we implement. Name choice is safe and straightforward. Our technology combines easily with an approach to syntax manipulation inspired by Huet's 'zippers'[10].Without the ideas in this paper, we would have struggled to implement EPIGRAM [19]. Our example-constructing inductive elimination operators for datatype families-is but one of many where it proves invaluable.},
  booktitle = {Proceedings of the 2004 ACM SIGPLAN Workshop on Haskell},
  pages     = {1–9},
  numpages  = {9},
  keywords  = {abstract syntax, bound variables, de Bruijn representation, free variables, fresh names, haskell, implementing epigram, induction principles},
  location  = {Snowbird, Utah, USA},
  series    = {Haskell '04}
}

@article{WashburnWeirich2008,
  author    = {Geoffrey Washburn and
               Stephanie Weirich},
  title     = {Boxes go bananas: Encoding higher-order abstract syntax with parametric polymorphism},
  journal   = {Journal of Functional Programming},
  volume    = {18},
  number    = {1},
  pages     = {87--140},
  year      = {2008},
  doi       = {10.1017/S0956796807006557},
  timestamp = {Sat, 19 Oct 2019 19:29:27 +0200},
  biburl    = {https://dblp.org/rec/journals/jfp/WashburnW08.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@misc{Wadler1998,
  author = {Philip Wadler},
  title  = {The Expression Problem},
  url    = {https://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt},
  year   = {1998},
  month  = {11},
  day    = {12},
  note   = {Accessed: 2024-11-07}
}

@misc{Cockx2021_blog,
  author  = {Cockx, Jesper},
  title   = {1001 Representations of Syntax with Binding},
  url     = {https://jesper.sikanda.be/posts/1001-syntax-representations.html},
  journal = {Jesper Cockx's homepage},
  year    = {2021},
  month   = {11},
  note    = {Accessed: 2023-01-21}
}

@misc{Kmett2008_CR,
  title   = {Rotten Bananas},
  url     = {http://comonad.com/reader/2008/rotten-bananas/},
  journal = {The Comonad{.}Reader},
  author  = {Kmett, Edward},
  year    = {2008},
  month   = {03},
  note    = {Accessed: 2024-11-07}
}

@misc{Kmett2015_SoH,
  title     = {Bound},
  url       = {{https://www.schoolofhaskell.com/user/edwardk/bound}},
  journal   = {School of Haskell},
  publisher = {FP Complete},
  author    = {Kmett, Edward},
  year      = {2015},
  month     = {12},
  note      = {Accessed: 2023-01-21}
}

@article{Chlipala2008,
  author     = {Chlipala, Adam},
  title      = {{Parametric Higher-Order Abstract Syntax for Mechanized Semantics}},
  year       = {2008},
  issue_date = {September 2008},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {43},
  number     = {9},
  issn       = {0362-1340},
  doi        = {10.1145/1411203.1411226},
  abstract   = {We present parametric higher-order abstract syntax (PHOAS), a new approach to formalizing the syntax of programming languages in computer proof assistants based on type theory. Like higher-order abstract syntax (HOAS), PHOAS uses the meta language's binding constructs to represent the object language's binding constructs. Unlike HOAS, PHOAS types are definable in general-purpose type theories that support traditional functional programming, like Coq's Calculus of Inductive Constructions. We walk through how Coq can be used to develop certified, executable program transformations over several statically-typed functional programming languages formalized with PHOAS; that is, each transformation has a machine-checked proof of type preservation and semantic preservation. Our examples include CPS translation and closure conversion for simply-typed lambda calculus, CPS translation for System F, and translation from a language with ML-style pattern matching to a simpler language with no variable-arity binding constructs. By avoiding the syntactic hassle associated with first-order representation techniques, we achieve a very high degree of proof automation.},
  journal    = {SIGPLAN Not.},
  month      = {09},
  pages      = {143–156},
  numpages   = {14},
  keywords   = {compiler verification, interactive proof assistants, dependent types, type-theoretic semantics}
}

@inproceedings{PfenningElliott1988,
  author    = {Frank Pfenning and
               Conal Elliott},
  editor    = {Richard L. Wexelblat},
  title     = {Higher-Order Abstract Syntax},
  booktitle = {{Proceedings of the {ACM}} SIGPLAN'88 Conference on Programming Language
               Design and Implementation (PLDI), Atlanta, Georgia, USA, June 22-24,
               1988},
  pages     = {199--208},
  publisher = {{ACM}},
  year      = {1988},
  doi       = {10.1145/53990.54010},
  timestamp = {Fri, 09 Jul 2021 14:03:46 +0200},
  biburl    = {https://dblp.org/rec/conf/pldi/PfenningE88.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@misc{Kudasov2024freescoped,
  title         = {{Free Monads, Intrinsic Scoping, and Higher-Order Preunification}},
  author        = {Nikolai Kudasov},
  year          = {2024},
  booktitle     = {Trends in Functional Programming: 25th International Symposium, TFP 2024, Orange, NJ, USA, January 10–12, 2024},
  location      = {Orange, NJ, USA},
  eprint        = {2204.05653},
  archiveprefix = {arXiv},
  primaryclass  = {cs.LO},
  note          = {To appear in \textit{TFP 2024}}
}

@inproceedings{OkasakiGill1998,
  title     = {Fast mergeable integer maps},
  author    = {Okasaki, Chris and Gill, Andrew},
  booktitle = {Workshop on ML},
  pages     = {77--86},
  year      = {1998}
}

@misc{Kudasov2022_arXiv_free_scoped,
  title           = {{Functional Pearl: Dependent type inference via free higher-order unification}},
  author          = {Nikolai Kudasov},
  year            = {2022},
  eprint          = {2204.05653},
  archiveprefix   = {arXiv},
  primaryclass    = {cs.LO},
  url             = {https://arxiv.org/abs/2204.05653},
  authorscopus    = {true},
  authorscopuswos = {true},
  authorother     = {true}
}

@article{chargueraud2012locally,
  title     = {The locally nameless representation},
  author    = {Chargu{\'e}raud, Arthur},
  journal   = {Journal of automated reasoning},
  volume    = {49},
  pages     = {363--408},
  year      = {2012},
  publisher = {Springer}
}

@inproceedings{FioreHur2010,
  author    = {Marcelo Fiore and
               Chung{-}Kil Hur},
  editor    = {Anuj Dawar and
               Helmut Veith},
  title     = {{Second-Order Equational Logic (Extended Abstract)}},
  booktitle = {Computer Science Logic, 24th International Workshop, {CSL} 2010, 19th
               Annual Conference of the EACSL, Brno, Czech Republic, August 23-27,
               2010. Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {6247},
  pages     = {320--335},
  publisher = {Springer},
  year      = {2010},
  url       = {https://doi.org/10.1007/978-3-642-15205-4\_26},
  doi       = {10.1007/978-3-642-15205-4\_26},
  timestamp = {Tue, 14 May 2019 10:00:42 +0200},
  biburl    = {https://dblp.org/rec/conf/csl/FioreH10.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{FioreSzamozvancev2022,
  title     = {Formal metatheory of second-order abstract syntax},
  author    = {Fiore, Marcelo and Szamozvancev, Dmitrij},
  year      = {2022},
  journal   = {Proceedings of the ACM on Programming Languages},
  volume    = {6},
  number    = {POPL},
  pages     = {1--29},
  publisher = {ACM New York, NY, USA}
}

@inproceedings{Xtext2010,
  author    = {Eysholdt, Moritz and Behrens, Heiko},
  title     = {Xtext: Implement Your Language Faster than the Quick and Dirty Way},
  year      = {2010},
  isbn      = {9781450302401},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1869542.1869625},
  doi       = {10.1145/1869542.1869625},
  abstract  = {Whether there is an (emerging or legacy) Domain-Specific Language to increase the expressiveness of your coworkers or whether you are about to invent a new General Purpose Prgramming Language: Tool support that goes beyond a parser/compiler is essential to make other people adopt your language and to be more productive. Xtext is an award- winning framework to build such tooling.In this tutorial we explain how to define a language and a statically typed, EMF-based Abstract Syntax Tree using only a grammar. We then generate a parser, a serializer and a smart editor from it. The editor provides many features out-of-the-box, such as syntax highlighting, content-assist, folding, jump-to-declaration and reverse-reference lookup across multiple files. Then, it is shown how literally every as- pects of the language and its complementary tool support can be customized using Dependency Injection, especially how this can be done for linking, formatting and validation. As an outlook, we will demonstrate how to integrate a custom language with Java, how Xtext maintains a workspace-wide index of named elements and how to implement incremental code generation or attach an interpreter.},
  booktitle = {Proceedings of the ACM International Conference Companion on Object Oriented Programming Systems Languages and Applications Companion},
  pages     = {307–309},
  numpages  = {3},
  keywords  = {modeling, EMF, Eclipse, MDSD, Xtext, DSL},
  location  = {Reno/Tahoe, Nevada, USA},
  series    = {OOPSLA '10}
}

@book{FlexBisonBook,
  title     = {Flex \& Bison: Text Processing Tools},
  author    = {Levine, John},
  year      = {2009},
  publisher = {" O'Reilly Media, Inc."}
}

@article{Antlr1995,
  title     = {ANTLR: A predicated-LL (k) parser generator},
  author    = {Parr, Terence J. and Quong, Russell W.},
  journal   = {Software: Practice and Experience},
  volume    = {25},
  number    = {7},
  pages     = {789--810},
  year      = {1995},
  publisher = {Wiley Online Library}
}

@article{Antlr2011,
  author     = {Parr, Terence and Fisher, Kathleen},
  title      = {LL(*): The Foundation of the ANTLR Parser Generator},
  year       = {2011},
  issue_date = {June 2011},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {46},
  number     = {6},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/1993316.1993548},
  doi        = {10.1145/1993316.1993548},
  abstract   = {Despite the power of Parser Expression Grammars (PEGs) and GLR, parsing is not a solved problem. Adding nondeterminism (parser speculation) to traditional LL and LR parsers can lead to unexpected parse-time behavior and introduces practical issues with error handling, single-step debugging, and side-effecting embedded grammar actions. This paper introduces the LL(*) parsing strategy and an associated grammar analysis algorithm that constructs LL(*) parsing decisions from ANTLR grammars. At parse-time, decisions gracefully throttle up from conventional fixed k>=1 lookahead to arbitrary lookahead and, finally, fail over to backtracking depending on the complexity of the parsing decision and the input symbols. LL(*) parsing strength reaches into the context-sensitive languages, in some cases beyond what GLR and PEGs can express. By statically removing as much speculation as possible, LL(*) provides the expressivity of PEGs while retaining LL's good error handling and unrestricted grammar actions. Widespread use of ANTLR (over 70,000 downloads/year) shows that it is effective for a wide variety of applications.},
  journal    = {SIGPLAN Not.},
  month      = {06},
  pages      = {425–436},
  numpages   = {12},
  keywords   = {nondeterministic parsing, deterministic finite automata, context-sensitive parsing, backtracking, glr, syntactic predicates, memoization, augmented transition networks, subset construction, semantic predicates, peg}
}

@misc{functionK,
  title = {{FunctionK}},
  url   = {https://typelevel.org/cats/datatypes/functionk.html}
}

@misc{polymorphic-function-types,
  title = {{Polumorphic function types}},
  url   = {https://dotty.epfl.ch/blog/2019/06/11/16th-dotty-milestone-release.html#polymorphic-function-types}
}

@misc{type-lambdas,
  title = {{Type lambdas}},
  url   = {https://docs.scala-lang.org/scala3/reference/new-types/type-lambdas.html}
}

@misc{scalaHKD,
  title = {{Scala Higher-Kinded Types}},
  url   = {https://www.baeldung.com/scala/higher-kinded-types}
}

@misc{lambda-n-ways,
  title  = {{Lambda-Calculus cooked n-ways}},
  url    = {https://github.com/sweirich/lambda-n-ways/tree/main},
  author = {Stephanie Weirich and Lennart Augustsson and Steven Shaw and Oleg Grenrus and Bertram Felgenhauer}
}

@misc{nbe,
  title = {{Normalization by Evaluation}},
  url   = {https://en.wikipedia.org/wiki/Normalisation_by_evaluation}
}

@article{Miller1991,
  author   = {Miller, Dale},
  title    = {{A Logic Programming Language with Lambda-Abstraction, Function Variables, and Simple Unification}},
  journal  = {Journal of Logic and Computation},
  volume   = {1},
  number   = {4},
  pages    = {497-536},
  year     = {1991},
  month    = {09},
  abstract = {{It has been argued elsewhere that a logic programming language with function variables and λ-abstractions within terms makes a good meta-programming language, especially when an object-language contains notions of bound variables and scope. The λProlog logic programming language and the related Elf and Isabelle systems provide meta-programs with both function variables and λ-abstractions by containing implementations of higher order unification. This paper presents a logic programming language, called Lλ, that also contains both function variables and λ-abstractions, although certain restrictions are placed on occurrences of function variables. As a result of these restrictions, an implementation of Lλdoes not need to implement full higher-order unification. Instead, an extension to first-order unification that respects bound variable names and scopes is all that is required. Such unification problems are shown to be decidable and to possess most general unifiers when unifiers exist. A unification algorithm and logic programming interpreter are described and proved correct. Several examples of using Lλ as a meta-programming language are presented.}},
  issn     = {0955-792X},
  doi      = {10.1093/logcom/1.4.497},
  url      = {https://doi.org/10.1093/logcom/1.4.497}
}

@inproceedings{MeijerFokkingaPaterson1991,
  author    = {Meijer, Erik
               and Fokkinga, Maarten
               and Paterson, Ross},
  editor    = {Hughes, John},
  title     = {Functional programming with bananas, lenses, envelopes and barbed wire},
  booktitle = {Functional Programming Languages and Computer Architecture},
  year      = {1991},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {124--144},
  abstract  = {We develop a calculus for lazy functional programming based on recursion operators associated with data type definitions. For these operators we derive various algebraic laws that are useful in deriving and manipulating programs. We shall show that all example functions in Bird and Wadler's ``Introduction to Functional Programming'' can be expressed using these operators.},
  isbn      = {978-3-540-47599-6}
}

@online{unification-fd,
  author  = {Wren Romano},
  title   = {\texttt{unification-fd}: Simple generic unification algorithms},
  url     = {https://hackage.haskell.org/package/unification-fd},
  urldate = {2024-11-07}
}

@misc{hypertypes,
  author       = {lamdu},
  title        = {Hypertypes - generic programming for heterogeneous recursive types},
  year         = {2024},
  howpublished = {\url{https://github.com/lamdu/hypertypes}}
}

@inproceedings{AbelPientka2011,
  author    = {Abel, Andreas
               and Pientka, Brigitte},
  editor    = {Ong, Luke},
  title     = {Higher-Order Dynamic Pattern Unification for Dependent Types and Records},
  booktitle = {Typed Lambda Calculi and Applications},
  year      = {2011},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {10--26},
  abstract  = {While higher-order pattern unification for the $\lambda$$\Pi$-calculus is decidable and unique unifiers exists, we face several challenges in practice: 1) the pattern fragment itself is too restrictive for many applications; this is typically addressed by solving sub-problems which satisfy the pattern restriction eagerly but delay solving sub-problems which are non-patterns until we have accumulated more information. This leads to a dynamic pattern unification algorithm. 2) Many systems implement $\lambda$$\Pi$$\Sigma$ calculus and hence the known pattern unification algorithms for $\lambda$$\Pi$ are too restrictive.},
  isbn      = {978-3-642-21691-6}
}

@inproceedings{LibalMiller2016,
  author    = {Libal, Tomer and Miller, Dale},
  title     = {{Functions-as-Constructors Higher-Order Unification}},
  booktitle = {1st International Conference on Formal Structures for Computation and Deduction (FSCD 2016)},
  pages     = {26:1--26:17},
  series    = {Leibniz International Proceedings in Informatics (LIPIcs)},
  isbn      = {978-3-95977-010-1},
  issn      = {1868-8969},
  year      = {2016},
  volume    = {52},
  editor    = {Kesner, Delia and Pientka, Brigitte},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address   = {Dagstuhl, Germany},
  url       = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.FSCD.2016.26},
  urn       = {urn:nbn:de:0030-drops-59810},
  doi       = {10.4230/LIPIcs.FSCD.2016.26},
  annote    = {Keywords: higher-order unification, pattern unification}
}

@inproceedings{Kudasov2023unif,
  title        = {{Generalising Huet-style Projections in E-unification for Second-Order Abstract Syntax}},
  author       = {Kudasov, Nikolai},
  url          = {https://inria.hal.science/hal-04128229},
  booktitle    = {{UNIF 2023 - 37th International Workshop on Unification}},
  address      = {Rome, Italy},
  organization = {{Veena Ravishankar and Christophe Ringeissen}},
  year         = {2023},
  month        = Jul,
  pdf          = {https://inria.hal.science/hal-04128229/file/UNIF_2023_paper_9.pdf},
  hal_id       = {hal-04128229},
  hal_version  = {v1}
}

@misc{MazzoliAbel2016_TypeCheckingUnification,
  title         = {Type checking through unification},
  author        = {Francesco Mazzoli and Andreas Abel},
  year          = {2016},
  eprint        = {1609.09709},
  archiveprefix = {arXiv},
  primaryclass  = {cs.PL},
  url           = {https://arxiv.org/abs/1609.09709}
}

@phdthesis{Juan2020,
  title  = {Practical Unification for Dependent Type Checking},
  author = {Juan, V{\'\i}ctor L{\'o}pez},
  year   = {2020},
  school = {Universidade Tecnica de Lisboa (Portugal)}
}

@book{Norell2007,
  title     = {Towards a practical programming language based on dependent type theory},
  author    = {Norell, Ulf},
  volume    = {32},
  year      = {2007},
  publisher = {Chalmers University of Technology}
}


@inproceedings{Pollack1990,
  title        = {Implicit syntax},
  author       = {Pollack, Robert},
  booktitle    = {Informal Proceedings of First Workshop on Logical Frameworks, Antibes},
  volume       = {4},
  pages        = {66},
  year         = {1990},
  organization = {Citeseer}
}

@article{Brady2013,
  title   = {Idris, a general-purpose dependently typed programming language: Design and implementation},
  volume  = {23},
  doi     = {10.1017/S095679681300018X},
  number  = {5},
  journal = {Journal of Functional Programming},
  author  = {Brady, Edwin},
  year    = {2013},
  pages   = {552–593}
}

@book{BertotCasteran2004,
  author    = {Yves Bertot and
               Pierre Cast{\'{e}}ran},
  title     = {Interactive Theorem Proving and Program Development - Coq'Art: The
               Calculus of Inductive Constructions},
  series    = {Texts in Theoretical Computer Science. An {EATCS} Series},
  publisher = {Springer},
  year      = {2004},
  url       = {https://doi.org/10.1007/978-3-662-07964-5},
  doi       = {10.1007/978-3-662-07964-5},
  isbn      = {978-3-642-05880-6},
  timestamp = {Tue, 16 May 2017 14:24:38 +0200},
  biburl    = {https://dblp.org/rec/series/txtcs/BertotC04.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
