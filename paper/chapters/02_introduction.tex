\chapter{Introduction}
\label{chap:intro}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Explain the (larger) context of your work (with references!).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In recent years, developers tend to prefer to use statically typed languages more often \cite{SODevSurvey2022} \cite{SODevSurvey2023} \cite{SODevSurvey2024}.
Even though JavaScript and Python are on top \cite{SODevSurvey2024}, projects like \href{https://www.typescriptlang.org/}{TypeScript} and \href{https://mypy-lang.org/}{MyPy} are gaining popularity as they introduce static typing to the languages that were purely dynamically typed in the beginning.
This trend is expected, as static typing provides many benefits like catching errors at compile time, serves as a form of documentation, helps with code completion and refactoring, and can even improve performance.
Beyond programming languages, type systems play an important role in implementation of proof assistants, theorem provers, and more.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Give a simple, but descriptive example of a problem that you are solving, or a problem that is a direct application of your work.
% The example should be maximally self-contained and be simple enough to convey the basic idea to the reader.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

However, implementing a correct and efficient type checker for a language is not an easy task.
An implementor of a modern language would have to support many non-trivial features like local variables (i.e. bound identifiers), polymorphism, type inference, type classes, and more.
While tools like BNFC \cite{BNFC} and Happy \cite{haskell_happy} assist in generating parsers for a language, the tools that would help in implementing the robust and efficient type systems remain a relatively novel field.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Provide an brief overview of approaches to the problem (with references!).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

Free Foil of Kudasov \textit{et al.} \cite{FreeFoil} has shown that it is possible to outsource the implementation of bound identifiers and scopes by generating a scope-safe abstract syntax in Haskell, thus allowing a user of this library to add support of binders to their language with extremely small effort.
This work is based on the same ideas and aims to create a Haskell library that would extend the Free Foil framework by providing to its users a generic and efficient typechecking algorithm with Hindley-Milner style type inference.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Briefly explain what are the idea behind your work and how it is different/compares against other approaches.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Other works trying to achieve the similar goal exist, for example \texttt{hypertypes} \cite{hypertypes} and work of Heeren \textit{et al.} on generalizing Hindley-Milner inference algorithms \cite{Heeren2002GeneralizingHindleyMilner}.

This work, in contrast, altogether with scope-safe abstract syntax of Free Foil as well as with the future works, would provide a toolkit of tested and efficient algorithms for a developer who wants to implement a language, therefore freeing they from the need to implement the core functionality from scratch.
Particularly, the Haskell library presented here will allow a developer to implement an efficient typechecker with support of \texttt{let}-polymorphism and subtyping-based constraints unification algorithm.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Clearly state (as an enumerated list) the contributions of your work (for now, this list is mostly "imaginary", this is what you would like your final contribution to be).
% It is important that your contribution is separated from related work (including other students working on similar topics).
% You may also specify your GitHub repository here.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The primary aims of this work are the following:

\begin{enumerate}
  \item Identify and implement crucial notions for a generic type system (e.g. typed terms, typing contexts, type schemes) within the Free Foil framework \cite{FreeFoil}.
  \item Generalize the Hindley-Milner type system \cite{Hindley1969PrincipalTypeScheme} \cite{Milner1978_TypePolymorphism} and Damas-Milner type inference \cite{DamasMilner1982_TypeSchemes} to Second-Order Abstract Syntax with safe-scoping within the Free Foil framework \cite{FreeFoil}.
  \item Implement an efficient level-based let-generalization algorithm based on work of RÃ©my \cite{Remy1992_SortedEqTheoryTypes}.
  \item Publish results of the first three points as a single Haskell package.
  \item Showcase the resulting library by implementing a typechecker for the simplified Haskell \cite{Jones1999_TypingHaskell}.
\end{enumerate}

Source code and other results of this work can be found in the GitHub repository: \href{https://github.com/evermake/free-foil-typecheck}{github.com/evermake/free-foil-typecheck}.
