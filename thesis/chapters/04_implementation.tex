\chapter{\todoorange{Implementation}}
\label{chap:implementation}

In this chapter, we present an implementation of the mentioned type inference algorithm in Haskell. First, we define object language grammar and generate front-end of the type checker. Second, we generate generic abstract syntax with Free Foil. Then, we introduce necessary data types and explain key steps in the algorithm. Finally, we talk about testing and related difficulties.

\section{\todogreen{Grammar and Front-end}}

The object language, for which the type checking is to be implemented is similar to the simply typed lambda-calculus but extended with let polymorphism, boolean and natural number literals. The grammar is defined in Labelled BNF (LBNF), and is divided into two parts: terms (or expressions) and types.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\todogreen{Expressions Grammar}}

The LBNF grammar for expressions is shown in Figure~\ref{fig:lbnf-terms}. We define 7 grammar rules for expressions:

\begin{itemize}
  \item \texttt{EVar} — variable identifier.
  \item \texttt{ETrue} and \texttt{EFalse} — boolean literals.
  \item \texttt{ENat} — natural number literal.
  \item \texttt{EApp} — function application. Note that subexpression on the right has a higher precedence level, since function application is left associative.
  \item \texttt{EAbs} — lambda abstraction, which binds a variable to be used in the nested expression.
  \item \texttt{ELet} — let-binding, which is similar to \texttt{EAbs} but has one more (not scoped) subexpression.
\end{itemize}

\texttt{Pattern} and \texttt{ScopedExp} rules are essentially wrappers around \texttt{Ident} and \texttt{Exp1} respectively, which are introduced to clearly identify a binder and corresponding scoped expressions where the bound pattern can occur. These rules are crucial for the scope-safe abstract syntax generation, which is described in the next section.

\begin{figure}[H]
  \begin{minted}[frame=single,fontsize=\small,escapeinside=@@]{text}
EVar.    Exp3 ::= Ident ;
ETrue.   Exp3 ::= "true" ;
EFalse.  Exp3 ::= "false" ;
ENat.    Exp3 ::= Integer ;
EApp.    Exp2 ::= Exp2 Exp3 ;
EAbs.    Exp1 ::= "@$\lambda$@" Pattern "." ScopedExp ;
ELet.    Exp1 ::= "let" Pattern "=" Exp1 "in" ScopedExp ;
coercions Exp 3 ;

PatternVar. Pattern ::= Ident ;
ScopedExp. ScopedExp ::= Exp1 ;
  \end{minted}
  \caption[LBNF grammar of the object language expressions]{Labelled BNF grammar of the object language expressions. \texttt{Ident} and \texttt{Integer} are predifined basic types in BNFC. The \texttt{coercions} is a macro that automatically generates semantic "no-op" coercion rules that define the precedence of the operators.}
  \label{fig:lbnf-terms}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\todogreen{Types Grammar}}

Figure~\ref{fig:lbnf-types} shows the LBNF grammar for types, which defines 6 grammar rules:

\begin{itemize}
  \item \texttt{TUVar} — free, or unification variable.
  \item \texttt{TBool} — boolean type.
  \item \texttt{TNat} — natural number type.
  \item \texttt{TVar} — type variable.
  \item \texttt{TArrow} — function type. Unlike function expressions, function types are right associative, therefore, rule to the left of the arrow has higher precedence.
  \item \texttt{TForAll} — "forall"-quantified type that binds a type variable in the inner type expression.
\end{itemize}

To distinguish between free and bound variables we prefix unification variable identifiers with "?" by introducing a new \texttt{UVarIdent} lexical type. And, similarly to term expressions, we also define separate \texttt{TypePattern} and \texttt{ScopedType} rules to further generate the scope-safe abstract syntax for types. In case of types, the only rule that binds a (type) variable and has a scoped subexpression is \texttt{TForAll}.

\begin{figure}[H]
  \begin{minted}[frame=single,fontsize=\small,escapeinside=@@]{text}
token UVarIdent ('?' letter (letter | digit | '_')*) ;

TUVar.   Type2 ::= UVarIdent ;
TNat.    Type2 ::= "Nat" ;
TBool.   Type2 ::= "Bool" ;
TVar.    Type2 ::= Ident ;
TArrow.  Type1 ::= Type2 "->" Type1 ;
TForAll. Type  ::= "forall" TypePattern "." ScopedType ;
coercions Type 2 ;

TPatternVar. TypePattern ::= Ident ;
ScopedType. ScopedType ::= Type1 ;
  \end{minted}
  \caption[LBNF grammar of the object language types]{Labelled BNF grammar of the object language types. \texttt{UVarIdent} is a custom lexical type introduced to distinguish unification (free) variables from bound variables, which use the predifined basic type \texttt{Ident}. The \texttt{coercions} is a macro that automatically generates semantic "no-op" coercion rules that define the precedence of the operators.}
  \label{fig:lbnf-types}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\todogreen{Code Generation}}

Having defined the language grammar, we are ready to generate the necessary Haskell code using code generation tools mentioned in the Chapter~\ref{chap:lr}. After installing necessary tools, and running shell commands from Figure~\ref{fig:code-gen-cli}, we get:

\begin{enumerate}
  \item Abstract syntax data types (\texttt{Abs.hs}), pretty-printing (\texttt{Print.hs}), lexer specification (\texttt{Lex.x}), and parser specification (\texttt{Par.y}) generated by BNFC~\cite{BNFC} from the grammar.
  \item Lexical analyzer (\texttt{Lex.hs}) generated by Alex~\cite{haskell_alex} from the lexer specification.
  \item Parser (\texttt{Par.hs}) generated by Happy~\cite{haskell_happy} from the parser specification.
\end{enumerate}

\begin{figure}[H]
  \begin{minted}[frame=single]{bash}
bnfc --haskell -d \
  -p FreeFoilTypecheck.HindleyMilner \
  --generic \
  -o src \
  grammar/Parser.cf
alex src/FreeFoilTypecheck/HindleyMilner/Parser/Lex.x
happy src/FreeFoilTypecheck/HindleyMilner/Parser/Par.y
  \end{minted}
  \caption{Shell commands for generating type checker front-end}
  \label{fig:code-gen-cli}
\end{figure}

\begin{figure}[H]
\begin{minted}[frame=single,fontsize=\small]{haskell}
newtype Ident = Ident String

data Pattern = PatternVar Ident
data Exp
  = EVar Ident
  | ETrue
  | EFalse
  | ENat Integer
  | EApp Exp Exp
  | ELet Pattern Exp ScopedExp
  | EAbs Pattern ScopedExp
data ScopedExp = ScopedExp Exp

newtype UVarIdent = UVarIdent String
data TypePattern = TPatternVar Ident
data Type
  = TUVar UVarIdent
  | TNat
  | TBool
  | TVar Ident
  | TArrow Type Type
  | TForAll TypePattern ScopedType
data ScopedType = ScopedType Type
\end{minted}
  \caption{Abstract syntax data types generated by BNFC}
  \label{fig:ast-types-bnfs}
\end{figure}

From the abstract syntax generated by BNFC showon on Figure~\ref{fig:ast-types-bnfs}, we now are able to generate the generic and scope-safe version of it via Free Foil.

\section{\todogreen{Generating Scope-Safe SOAS}}

The Free Foil framework is accessible in Haskell via the free-foil package~\cite{free-foil}. To generate scope-safe second-order representation of the syntactical constructs of our language, Free Foil requires the first-order syntax to be organized in four types~\cite{FreeFoil}: \textit{variable identifiers}, \textit{patterns} (binders), \textit{scoped terms}, and (unscoped) \textit{terms}. This is exactly what we have generated with BNFC (Figure~\ref{fig:ast-types-bnfs}). In total, we supply free-foil with 7 types to generate SOAS, since we use expressions and types separately:

\begin{enumerate}
  \item \texttt{Ident} — type of \textit{variable identifier} in both expressions and types.
  \item \texttt{Pattern} — type of \textit{pattern} in expressions.
  \item \texttt{ScopedExp} — type of \textit{scoped terms} in expressions.
  \item \texttt{Exp} — type of \textit{terms} in expressions.
  \item \texttt{TypePattern} — type of \textit{patterns} in types.
  \item \texttt{ScopedType} — type of \textit{scoped terms} in types.
  \item \texttt{Type} — type of \textit{terms} in types.
\end{enumerate}

Code on Figure~\ref{fig:soas-gen} generates signature for type expressions, necessary class instances, and other helpers to be used later. \texttt{Type n} is a type synonym with phantom parameter \texttt{n}, which represents a single AST node in scope \texttt{n}, and is used throughout the implementation. \texttt{Type'} is a synonym for a type expression in empty scope, i.e. in the scope where all variables (if any) are bound.

\begin{figure}[H]
\begin{minted}[frame=single,fontsize=\small]{haskell}
-- Signature
mkSignature ''Raw.Type ''Raw.Ident ''Raw.ScopedType ''Raw.TypePattern
deriveZipMatch ''TypeSig
deriveBifunctor ''TypeSig
deriveBifoldable ''TypeSig
deriveBitraversable ''TypeSig

-- Pattern synonyms
mkPatternSynonyms ''TypeSig

--Conversion helpers
mkConvertToFreeFoil ''Raw.Type ''Raw.Ident ''Raw.ScopedType ''Raw.TypePattern
mkConvertFromFreeFoil ''Raw.Type ''Raw.Ident ''Raw.ScopedType ''Raw.TypePattern

-- Scope-safe type patterns
mkFoilPattern ''Raw.Ident ''Raw.TypePattern
deriveCoSinkable ''Raw.Ident ''Raw.TypePattern
mkToFoilPattern ''Raw.Ident ''Raw.TypePattern
mkFromFoilPattern ''Raw.Ident ''Raw.TypePattern

type Type n = AST FoilTypePattern TypeSig n
type Type' = Type Foil.VoidS
\end{minted}
  \caption{SOAS generation with free-foil's Template Haskell functions}
  \label{fig:soas-gen}
\end{figure}

\section{\todoorange{Inference Algorithm}}

<TODO: описываю детали реализации ”для реализации мы выбрали простые типы данных (строки, map) и не используем эффективные библиотеки — можно аргументировать: потому что реализация “self-contained“, т.е. она простая, но зато её легко понять”>

\begin{figure}[H]
  \begin{minted}[frame=single,fontsize=\small]{haskell}
type IdentLevelMap = HashMap.HashMap Raw.UVarIdent Int

instance Data.Hashable.Hashable Raw.UVarIdent where
  hashWithSalt salt (Raw.UVarIdent s) = Data.Hashable.hashWithSalt salt s

newtype Constraint n = Constraint (Type n, Type n)
type Constraint' = Constraint Foil.VoidS

newtype Subst n = Subst (Map.Map Raw.UVarIdent (Type n))
type Subst' = Subst Foil.VoidS

newtype TypingEnv n tn = TypingEnv (Foil.NameMap n (Type tn))
type TypingEnv' n = TypingEnv n Foil.VoidS

class Typed a where
  applySubst :: (Foil.Distinct n) => Subst n -> a n -> a n

  freeVars :: a n -> Set.Set Raw.UVarIdent

  hasFreeVar :: Raw.UVarIdent -> a n -> Bool
  hasFreeVar i t = i `Set.member` freeVars t

instance Typed (FreeFoil.AST FoilTypePattern TypeSig) where
  applySubst (Subst s) t = foldr applySubstToType t (Map.toList s)

  freeVars (TUVar ident) = Set.singleton ident
  freeVars (FreeFoil.Var _) = Set.empty
  freeVars (FreeFoil.Node node) = Set.unions $ freeVars <$> node

instance Typed Constraint where
  applySubst s (Constraint (t1, t2)) = Constraint (applySubst s t1, applySubst s t2)

  freeVars (Constraint (t1, t2)) = Set.union (freeVars t1) (freeVars t2)

instance Typed (TypingEnv n) where
  applySubst s (TypingEnv env) = TypingEnv (fmap (applySubst s) env)
  freeVars (TypingEnv env) = Set.unions $ freeVars <$> env

idSubst :: Subst Foil.VoidS
idSubst = Subst Map.empty

singleSubst :: (Foil.Distinct n) => Raw.UVarIdent -> Type n -> Subst n
singleSubst ident type_ = Subst (Map.singleton ident type_)

composeSubst :: (Foil.Distinct n) => Subst n -> Subst n -> Subst n
composeSubst (Subst s1) (Subst s2) = Subst (Map.map (applySubst (Subst s2)) s1 `Map.union` s2)
  \end{minted}
  \caption{todo}
  % \label{}
\end{figure}

...

\begin{figure}[H]
  \begin{minted}[frame=single,fontsize=\small]{haskell}
data TypingContext n = TypingContext
  { tcConstraints :: [Constraint'],
    tcSubst :: Subst',
    tcEnv :: TypingEnv' n,
    tcFreshId :: Int,
    tcLevelMap :: IdentLevelMap,
    tcLevel :: Int
  }

initialTypingContext :: TypingContext Foil.VoidS
initialTypingContext =
  TypingContext
    { tcConstraints = [],
      tcSubst = Subst Map.empty,
      tcEnv = TypingEnv Foil.emptyNameMap,
      tcFreshId = 1,
      tcLevelMap = HashMap.empty,
      tcLevel = 1
    }
  \end{minted}
  \caption{todo}
  % \label{}
\end{figure}

...

\texttt{inferType} takes an expression and returns monadic operation that performs type inference. More precisely, it takes a value of type \texttt{Exp n} and returns \texttt{TypeInferencer n Type'}, where:

\begin{itemize}
  \item \texttt{Exp n} is a synonym for \texttt{AST FoilPattern ExpSig n}, where
  \begin{itemize}
    \item \texttt{AST} — ???
    \item \texttt{FoilPattern} — ???
    \item \texttt{ExpSig} — ???
    \item \texttt{n} — ``phantom'' type parameter used required to avoid mixing different scopes on the type level.
  \end{itemize}
  \item \texttt{TypeInferencer n Type'} has two type parameters:
  \begin{itemize}
    \item \texttt{n} — S kind
    \item \texttt{Type'} — type of a payload that returned when type inferencer is computed, synonym for \texttt{AST FoilTypePattern TypeSig Foil.VoidS}
  \end{itemize}
\end{itemize}

How \texttt{inferType} works? It recursively infers a type of a given AST node (type \texttt{Exp n}) by pattern matching constructor of a node. For each node constructor, we define how type inference works for this specific node type. Let us consider the process for each type in detail:

\begin{itemize}
  \item \texttt{ETrue} and \texttt{EFalse} constructors do not have any parameters as they simply represent \texttt{true} and \texttt{false} boolean literals in the target language accordingly. \textless just \texttt{TBool}\textgreater
  \item \texttt{ENat} has one parameter of type \texttt{Integer} — value of the number literal, which does not affect the type inference and hence is ignored. \textless just \texttt{TNat}\textgreater
  \item \texttt{FreeFoil.Var} is special as
\end{itemize}

\section{\todored{Unification}}

We implement a standard unification algorithm according to Robinson~\cite{Robinson1965} in the \texttt{unifyConstraint} (Figure~\ref{fig:unifyConstraint}) function with two peculiarities.

First, we rely on free-foil's \texttt{zipMatch} function that unifies two arbitary AST nodes, which are then converted to constraints to further unify recursively with \texttt{unifyConstraints}. Since \texttt{zipMatch} is generic, unification works universally for all node types in AST.

Second, as our implementation of generalization relies on levels, level assigned to a type variable is updated during unification~\cite{Kiselyov2022_OCamplTypeChecker}, and since in our implementation a mapping is defined by \texttt{IdentLevelMap}, we need to update it.

\texttt{unifyConstraint} is splitted into two logical parts:

...

\begin{figure}[H]
  \begin{minted}[frame=single,fontsize=\small]{haskell}
unifyConstraint
  :: IdentLevelMap
  -> Constraint'
  -> Either String (Subst', IdentLevelMap)
unifyConstraint levelsMap (Constraint constr) =
  case constr of
    (TUVar x, r) -> case r of
      TUVar y
        | x == y -> Right (idSubst, levelsMap)
        | otherwise -> unifyWithUVar levelsMap x r
      _ -> unifyWithUVar levelsMap x r
    (l, TUVar x) -> unifyWithUVar levelsMap x l
    (FreeFoil.Node l, FreeFoil.Node r) ->
      case FreeFoil.zipMatch l r of
        Nothing -> Left ("cannot unify " ++ show constr)
        Just lr -> unifyConstraints levelsMap (Constraint <$> F.toList lr)
    (lhs, rhs) -> Left ("cannot unify " ++ show lhs ++ show rhs)
  \end{minted}
  \caption{...}
  \label{fig:unifyConstraint}
\end{figure}

...

\begin{figure}[H]
  \begin{minted}[frame=single,fontsize=\small]{haskell}
unifyWithUVar
  :: IdentLevelMap
  -> Raw.UVarIdent
  -> Type'
  -> Either String (Subst', IdentLevelMap)
unifyWithUVar levelsMap x type_
  | hasFreeVar x type_ = Left "occurs check failed"
  | otherwise = case HashMap.lookup x levelsMap of
      Nothing -> Left "type variable w/o level"
      Just level ->
        let vars = Set.toList (freeVars type_)
            withXLevels = HashMap.fromList [(var, level) | var <- vars]
            updatedLevels = HashMap.unionWith min levelsMap withXLevels
          in Right (singleSubst x type_, updatedLevels)
  \end{minted}
  \caption{...}
  % \label{}
\end{figure}

\section{\todogreen{Testing}}

A test suite consisting of 19 ill typed and 33 well typed programs has been developed when implementing the type inference. This helped to find bugs during development and, to some extent, verify the correctness of the implemented algorithm.

Test cases with ill typed programs check that inference algorithm indeed fails to infer type of such programs. For an ill typed program, test case passes only if the \texttt{inferTypeClosed} returns an error, for example, when unification of \texttt{TBool} with \texttt{TNat} is attempted, or when "occurs check" fails. We, however, do not check that the exact reason of failure is as expected for ill typed programs, which is left for the future work.

Test cases with well typed programs check that the inference algorithm successfully infers the type and it is correct. In order to check that the inferred type is correct, each well typed program is accompanied with additional file that contains the expected type of a program. For a well type program, test case passes only if the \texttt{inferTypeClosed} successfully returns a type that matches the expected type. By "matches" we mean that two polymorphic types are alpha-equivalent, except that the order of \texttt{forall} binders does not matter, in other words, we assume that types $\forall \alpha. \forall \beta. \alpha \to \beta$ and $\forall \beta. \forall \alpha. \alpha \to \beta$ are equal (which R\'emy called $\forall$-equality~\cite{Remy1992_SortedEqTheoryTypes}). Such assumption made it easier to add new test cases, as we do not need to think about implementation details when specifying expected types for the well typed programs.

It is worth mentioning how the comparison of an actual and expected types is implemented for a well typed test case, which is not straightforward. We could use the \texttt{alphaEquiv} function provided by the free-foil package for this purpose. However, it does not distinguish values of the literals (as illustrated in Figure~\ref{fig:freefoil-alphaequiv-literals}), and, therefore, is not suitable for comparing types containing free variables. A possible workaround would be to generalize both types before performing a comparison, as this would replace all free type variables with the variables bound by "forall"s. But still, this will not work in our case (see Figure~\ref{fig:freefoil-alphaequiv-foralls}), since we do not want the order of "forall"s in the types to influence the comparison. Therefore, free-foil's \texttt{alphaEquiv} does not fit our needs and another approach is necessary.

\begin{figure}[H]
  \begin{minted}[frame=single,fontsize=\small]{haskell}
>>> t1 = ("?a -> ?a" :: Type')
>>> t2 = ("?a -> ?b" :: Type')
>>> FreeFoil.alphaEquiv Foil.emptyScope t1 t2
True

>>> e1 = ("1" :: Exp')
>>> e2 = ("2" :: Exp')
>>> FreeFoil.alphaEquiv Foil.emptyScope e1 e2
True
  \end{minted}
  \caption[\texttt{FreeFoil.alphaEquiv} usage examples (1)]{Examples demonstrating that \texttt{FreeFoil.alphaEquiv} does not distinguish between different variable names or literal values.}
  \label{fig:freefoil-alphaequiv-literals}
\end{figure}

\begin{figure}[H]
  \begin{minted}[frame=single,fontsize=\small]{haskell}
>>> t1 = ("forall a. (forall b. a -> b)" :: Type')
>>> t2 = ("forall x. (forall y. x -> y)" :: Type')
>>> t3 = ("forall b. (forall a. a -> b)" :: Type')
>>> FreeFoil.alphaEquiv Foil.emptyScope t1 t2
True
>>> FreeFoil.alphaEquiv Foil.emptyScope t1 t3
False
  \end{minted}
  \caption[\texttt{FreeFoil.alphaEquiv} usage examples (2)]{Examples demonstrating that \texttt{FreeFoil.alphaEquiv} considers types with different variable names as equivalent, but is sensitive to the order of nested \texttt{forall}s.}
  \label{fig:freefoil-alphaequiv-foralls}
\end{figure}

Formally, we consider two polymorphic types equal (see Figure~\ref{fig:equiv-poly-rule}) if there exists a substitution of their bound type variables such that, after applying this substitution, the two types become syntactically identical, i.e. alpha-equivalent, regardless of the order in which the "forall" quantifiers appear. In the implementation, we compare two polymorphic types using the \texttt{equivPoly} function (see Figure~\ref{fig:equiv-poly-impl}), which works as follows.

First, we generalize both types for all present variables and immediately specialize them (lines 3 and 4). By doing this, we re-assign all existing free variables, if any, with the fresh ones, which is necessary to make sure all variables are present in the \texttt{tcLevelMap} in the \texttt{TypeInferencer} context, which is used later. Also, specialized types now can only have free type variables, i.e. no \texttt{forall}s will be present in the types. Moreover, \texttt{xs} and \texttt{ys} returned by \texttt{specialize} contain all type variables in the types, since they were generalized before, so at this step we may already conclude that \texttt{l} and \texttt{r} are not equal, if the number of unique type variables differs, that is \texttt{length xs /= length ys} (lines 5 and 6). If it is not the case, we proceed further.

Next, we actually need to perform the alpha equivalence check. However, as was mentioned earlier, \texttt{FreeFoil.alphaEquiv} will not work correctly with the free variables. We solve the problem by using the already mentioned unification algorithm in order to unify a single constraint, in other words, we solve a single equation of form $l = r$ to get a substitution \texttt{subst}.

Finally, after obtaining the substitution, we check that it matches all type variables from the left type to those in the right type, and that all variables are accounted for, ensuring a one-to-one correspondence between variables in both types. If the substitution is not found, or type variables in \texttt{l} do not correspond to type variables in \texttt{l}, we conclude that types are not equal. The reason why \texttt{equivPoly} works in the \texttt{TypeInferencer} context and uses the \texttt{tcLevelMap} is only because \texttt{specialize} and \texttt{unifyConstraint} need this, which, could be avoided, but kept for the sake of simplicity of the implementation.

\begin{figure}[H]
  \begin{prooftree*}
    \hypo{T_2 = [x_1 \mapsto y_{i_1}, \ldots, x_n \mapsto y_{i_n}] T_1}
    \hypo{\{y_{i_1}, \ldots, y_{i_n}\} = \{y_1, \ldots, y_n\}}
    \infer2{ \forall \{x_1, \ldots, x_n\}. T_1 = \forall \{y_1, \ldots, y_n\}. T_2}
  \end{prooftree*}
  \caption{Equivalence of polytypes}
  \label{fig:equiv-poly-rule}
\end{figure}

\begin{figure}[H]
  \begin{minted}[frame=single,fontsize=\small,linenos]{haskell}
equivPoly :: Type' -> Type' -> TypeInferencer n Bool
equivPoly l r = do
  (l', xs) <- specialize $ genAll l
  (r', ys) <- specialize $ genAll r
  if length xs /= length ys
    then return False
    else do
      levelMap <- gets tcLevelMap
      case unifyConstraint levelMap (Constraint (l', r')) of
        Left _ -> return False
        Right (Subst subst, _) -> do
          let matchings = [(x, y) | (x, TUVar y) <- Map.toList subst]
              allXs = List.sort xs == List.sort (map fst matchings)
              allYs = List.sort ys == List.sort (map snd matchings)
          return (allXs && allYs)
  where
    genAll t = generalizeWithIdents (Set.toList (freeVars t)) t
  \end{minted}
  \caption{\texttt{equivPoly} function for equivalence check of polytypes}
  \label{fig:equiv-poly-impl}
\end{figure}
