\chapter{\todored{Evaluation and Discussion}}
\label{chap:evaluation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% подробно расписываю анализ своей реализации, что получилось хорошо, что нет, на какие компромиссы пришлось пойти + вывод “как можно использовать то, что я сделал в этой работе“
% тут же Future Work:
%  - Обобщение всего этого подхода. Сейчас “заложен фундамент”, в дальнейшем можно сделать обобщённый Hindley-Milner с уровнями.
%  - Использование эффективных структур данных и алгоритма унификации через существующие библиотеки.
%  - Моя работа это Proof-of-Concept: есть Free Foil, в него можно добавить уровни

% Тут должен быть ответ на вопрос: “что всё это значит?”, выводы из моей работы.
% Возможные выводы:
%   Haskell хорош/плох для таких-то задач
%   free-foil хорош/плох для реализации тайпчекера (безопасность, скорость и т.п.) или наоборот какие-то трудности
%   сравнение производительности
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\todored{Conclusions}}

\begin{enumerate}
  \item Using free foil and BNFC makes its' easy to add new terms: we only need to extend grammar, and: (1) parser and abstract syntax will be automatically generated with BNFC and Free Foil (2) places that are non-generic will be highlighted by Haskell's type system (3) generic algorithms will not even require any modifications, since they are generic
\end{enumerate}

\section{\todored{Future Work}}

\begin{itemize}
  \item it's a toy language, possible problems may arise when implementing features for the real language (error messages, code editing suggestions)
  \item unification is crucial; algorithm presented here is simple and not proved theoretically, we could also outsource it too to other libraries
\end{itemize}

...

\begin{itemize}
  \item \textbf{Conclusion:} The generality and scope-safety nature of the abstract syntax generated by Free Foil has shown to be very helpful during the implementation. Generality — it's easy to extend, we can reuse implemented algorithms. Scope-safety — name management is outsorced with efficient algorithm and Haskell's type systems prevents us from making mistakes.
  \item \textbf{Limitation:} Error messages, Language-Server-Protocol...
  \item \textbf{Limitation:} Performance: unification is based on simple algorithm (Robinson's? exponential worst-case?). 
  \item \textbf{Future work:} More efficient unification algorithms exist (mention some works). Moreover, it's possible to outsource unification on some general unification algorithm (find some works to mention).
  \item \textbf{Future work:} HM algorithm can be generalized (mention HM(x) and hypertypes?) altogether with levels for more efficient generalization?
  \item \textbf{Future work:} Benchmarks for generalization w/and w/o levels?
  \item \textbf{Future work:} Levels are stored in map, instead we can use a separate data structure for unification variables.
\end{itemize}
