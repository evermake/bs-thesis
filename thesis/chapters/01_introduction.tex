\chapter{Introduction}
\label{chap:intro}

Type system is a crucial part of any formal system, such as a programming language or a proof assistant. In a world of functional programming, the discovery of the Hindley-Milner (HM) type system played an important role in the field advancement. Although easy to implement, the classical algorithm $\mathcal{W}$~\cite{Milner1978_TypePolymorphism} can infer the principal type scheme~\cite{Hindley1969_PrincipalTypeScheme} of a term without any hints from a programmer. Moreover, both its soundness and completeness have been theoretically proven~\cite{Damas1984_TypeAssignment}. Ideas discovered by Hindley, Milner, and Damas are at the core of type systems of today's most powerful functional programming languages like ML, OCaml, and Haskell.

Numerous implementations of the Hindley-Milner type system can be found in open-source projects and academic literature. Besides the original algorithms $\mathcal{W}$~and~$\mathcal{J}$~\cite{Milner1978_TypePolymorphism} introduced in late 1978, other variations of HM-style inference with different goals have arisen in recent decades, such as with deferred constraint solving (Heeren \textit{et~al.}, 2002~\cite{Heeren2002_GeneralizingHM}) or coercive subtyping (Traytel \textit{et~al.}, 2011~\cite{Traytel2011_HMCoerciveSubtyping}).

Despite the abundance of existing variations and examples, building a correct, efficient, and maintainable implementation of the Hindley-Milner type system, especially with the prospect of future extension, remains a challenging task. For instance, let-generalization in $\mathcal{W}$ is done by traversing the whole type environment~\cite{DamasMilner1982_TypeSchemes}, which can be inefficient. An alternative rank-based (or level-based) generalization, introduced by R\'emy~\cite{Remy1992_SortedEqTheoryTypes}, has been employed in OCaml~\cite{Kiselyov2022_OCamplTypeChecker} and Glasgow Haskell Compiler (GHC) to achieve better efficiency, though it remains relatively obscure.

Scopes management and capture-avoiding substitution are other obstacles faced by type checker implementors. Efficient and correct implementation of abstract syntax with binders is painless, which is why the Google research team developed the "foil"~\cite{Foil} — a technique for achieving scope-safe and fast substitutions for scoped abstract syntax trees (AST). Free~Foil~\cite{FreeFoil} combines foil with data types à la carte approach~\cite{Swierstra2008_a_la_carte}, to make foil's efficient and scope-safe syntax representation also generic. Generic AST representation makes it easy to extend functionality with new language terms and recursive operations, such as substitution, or alpha equivalence check.

We believe that a type-checking algorithm can be a generic and modular component, enabling easier prototyping of new type systems, in a similar way how Free Foil simplifies adding support of binders to a language.

This work makes a small step towards the belief with the following contributions. First, we propose a Hindley-Milner-style type inference algorithm with level-based generalization and separated constraint generation and solving. Second, we demonstrate an algorithm implementation in Haskell, which is based on generic abstract syntax with binders generated with Free~Foil, for a language similar to lambda calculus. Third, we test the correctness of the algorithm on a test suite with both well- and ill-typed sets of programs. Finally, we propose further steps for creating a generic version of the implemented algorithm, which could be used as a flexible type inference library once created.

The source code of this work can be found on GitHub at \href{https://github.com/evermake/free-foil-typecheck/tree/hm-levels}{github.com/evermake/free-foil-typecheck/tree/hm-levels}.
